import { TRPCError } from "@trpc/server"
import _ from "lodash"

import { publicProcedure } from "../../trpc"
import { SetRemoteCompanionStateInputSchema } from "../schemas/RemoteState"
import { checkAndForkExistingCompanion } from "../utils/checkAndForkExistingCompanion"

export const setCompanionStateProcedure = publicProcedure
	.input(SetRemoteCompanionStateInputSchema)
	.mutation(async ({ input, ctx }) => {
		if (!input) {
			throw new TRPCError({
				code: "BAD_REQUEST",
				message: "Invalid companion state provided",
			})
		}

		const { shortId, existingCompanion } =
			await checkAndForkExistingCompanion({
				remoteId: input.remoteId,
				ctx,
			})

		const pickedColumns = _.pickBy(
			// Remove undefined values to only changes values that are defined
			{
				savedInputs: input.companionState.saveTray?.savedShapes,
				savedConfiguration: input.companionState.configuration,

				// If our current user is the anonymous owner and is also logged in, we want to update the permanent owner to the logged in userId
				owner:
					existingCompanion?.anonymousOwner === ctx.anonymousUserId
						? ctx.userId ?? undefined
						: undefined,
			},
			(value) => value !== undefined,
		)

		const savedCompanion = await ctx.db.savedCompanion.upsert({
			where: { shortId },
			update: pickedColumns,
			create: {
				//TODO FIND A BETTER WAY TO CAST THIS
				...(existingCompanion as unknown as any),
				...pickedColumns,
				id: undefined, //resets the main id to be generated by the database
				shortId,
				owner: ctx.userId,
				anonymousOwner: ctx.anonymousUserId,
			},
		})

		return {
			remoteId: savedCompanion.shortId,
		}
	})
